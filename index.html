<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Recognizer</title>
    <!-- TensorFlow.js library -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
            background-color: #f4f4f4;
        }
        h1 {
            color: #333;
        }
        #canvas-container {
            border: 2px solid #ccc;
            background-color: white;
            margin-bottom: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        canvas {
            display: block;
        }
        .controls button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 5px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }
        #predictButton {
            background-color: #4CAF50;
            color: white;
        }
        #predictButton:hover {
            background-color: #45a049;
        }
        #clearButton {
            background-color: #f44336;
            color: white;
        }
        #clearButton:hover {
            background-color: #da190b;
        }
        #prediction {
            margin-top: 20px;
            font-size: 2em;
            font-weight: bold;
            color: #007bff;
        }
        .loading {
            color: #555;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <h1>Draw a Digit</h1>
    <p>Draw a single digit (0-9) in the box below, then click "Predict".</p>

    <div id="canvas-container">
        <canvas id="digitCanvas" width="280" height="280"></canvas>
    </div>

    <div class="controls">
        <button id="predictButton">Predict</button>
        <button id="clearButton">Clear</button>
    </div>

    <div id="prediction">
        Prediction: <span id="predictionResult">_</span>
    </div>

    <div class="loading" id="loadingMessage">Loading model...</div>

    <script>
        const canvas = document.getElementById('digitCanvas');
        const ctx = canvas.getContext('2d');
        const predictButton = document.getElementById('predictButton');
        const clearButton = document.getElementById('clearButton');
        const predictionResult = document.getElementById('predictionResult');
        const loadingMessage = document.getElementById('loadingMessage');

        let model;
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        const CANVAS_SIZE = 280; // Size of the display canvas
        const MODEL_INPUT_SIZE = 28; // Size required by the model (28x28)

        // Set up canvas for drawing
        ctx.lineWidth = 15;
        ctx.lineCap = 'round';
        ctx.strokeStyle = 'black';
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE); // Initialize canvas with white background

        // Load the TensorFlow.js model
        async function loadModel() {
            try {
                // Ensure model.json and group1-shard1of1.bin are in the same directory
                // or provide the correct relative path to model.json
                model = await tf.loadLayersModel('./model.json');
                console.log('Model loaded successfully!');
                loadingMessage.style.display = 'none';
                predictButton.disabled = false;
                clearButton.disabled = false;
            } catch (error) {
                console.error('Error loading model:', error);
                loadingMessage.textContent = 'Error loading model. Check console for details.';
                predictButton.disabled = true;
                clearButton.disabled = true;
            }
        }

        // Drawing functions
        function drawStart(e) {
            isDrawing = true;
            [lastX, lastY] = getCanvasCoordinates(e);
        }

        function drawMove(e) {
            if (!isDrawing) return;
            e.preventDefault(); // Prevent scrolling on touch devices
            let [x, y] = getCanvasCoordinates(e);
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);
            ctx.stroke();
            [lastX, lastY] = [x, y];
        }

        function drawEnd() {
            isDrawing = false;
        }

        function getCanvasCoordinates(e) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            return [clientX - rect.left, clientY - rect.top];
        }

        // Preprocess the image for prediction
        function preprocessImage(imageData) {
            return tf.tidy(() => {
                // Create an off-screen canvas to resize and convert to grayscale
                const offscreenCanvas = document.createElement('canvas');
                offscreenCanvas.width = MODEL_INPUT_SIZE;
                offscreenCanvas.height = MODEL_INPUT_SIZE;
                const offscreenCtx = offscreenCanvas.getContext('2d');

                // Draw the user's drawing onto the off-screen canvas (scaling it down)
                offscreenCtx.drawImage(imageData, 0, 0, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE);

                // Get image data from the off-screen canvas
                const imgData = offscreenCtx.getImageData(0, 0, MODEL_INPUT_SIZE, MODEL_INPUT_SIZE);
                let tensor = tf.browser.fromPixels(imgData, 1); // Get grayscale (1 channel)
                
                // Invert colors and normalize to [0, 1] for MNIST (black background, white digit)
                // If your model expects white background, black digit, remove the 1.0 - tensor part.
                tensor = tf.cast(tensor, 'float32').div(255.0);
                tensor = tf.sub(1.0, tensor); // Invert colors (MNIST digits are white on black background)

                // Reshape to [1, 784] for your model's input
                return tensor.reshape([1, MODEL_INPUT_SIZE * MODEL_INPUT_SIZE]);
            });
        }

        // Predict function
        async function predictDigit() {
            if (!model) {
                predictionResult.textContent = 'Model not loaded yet.';
                return;
            }

            // Get the image data from the main canvas
            const imageData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            const processedTensor = preprocessImage(imageData);

            // Make prediction
            const prediction = model.predict(processedTensor);
            const probabilities = prediction.dataSync(); // Get the raw probabilities
            const predictedClass = prediction.argMax(-1).dataSync()[0]; // Get the index of the highest probability

            predictionResult.textContent = predictedClass;
            
            // Log probabilities for debugging (optional)
            console.log('Probabilities:', probabilities);
            console.log('Predicted class:', predictedClass);

            // Clean up tensors
            processedTensor.dispose();
            prediction.dispose();
        }

        // Clear canvas function
        function clearCanvas() {
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE); // Reset to white background
            predictionResult.textContent = '_';
        }

        // Event Listeners
        canvas.addEventListener('mousedown', drawStart);
        canvas.addEventListener('mousemove', drawMove);
        canvas.addEventListener('mouseup', drawEnd);
        canvas.addEventListener('mouseout', drawEnd); // Stop drawing if mouse leaves canvas

        // For touch devices
        canvas.addEventListener('touchstart', drawStart);
        canvas.addEventListener('touchmove', drawMove);
        canvas.addEventListener('touchend', drawEnd);
        canvas.addEventListener('touchcancel', drawEnd);

        predictButton.addEventListener('click', predictDigit);
        clearButton.addEventListener('click', clearCanvas);

        // Disable buttons until model is loaded
        predictButton.disabled = true;
        clearButton.disabled = true;

        // Initial model load
        loadModel();
    </script>
</body>
</html>
